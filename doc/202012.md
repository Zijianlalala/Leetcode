# 12月刷题记录

## 12.1 周二
### 34.在排序数组中查找元素的第一个和最后一个位置
> BBTime：12月份了！冲！今天开始打算除了leecode每日一题外，再加上一道剑指offer的题

这道题没什么好说的，可能只是单纯的考察二分查找吧

### c3.数组中的重复数字
常规思路：用哈希表记录出现的数量，再找哈希表中`value`大于1的`key`。
![c3通过截图](../imgs/c3.jpg)

优化1，在构建哈希表的时候就可以找到重复的数了。
![优化1通过截图](../imgs/c3(2).jpg)

优化2，因为题目中说到长度为`n`的`nums`数组范围`在0~n-1`内，所以直接用长度为`n`的数组替代`hashmap`。

![优化2通过截图](../imgs/c3(3).jpg)

使用空间复杂度为`O(1)`的算法，重排数组。

## 12.2 周三
### 321.拼接最大数
> BBTime：尝试了一下，只是单纯地找两个数组的最大值，比较一下，然后放到新数组中，但这也不一定是最大数啊。感觉不是我能做出来的git题，故放弃。

思路
1. 遍历`[k1, k2]`为` [0, k],[1,k-1],...[i, k-i],...[k, 0]`种组合时的最大数，且满足`k1 <= m, k2 <=n`
2. 找出两个数组中最大子序列（单调栈）
3. 将其合并
4. 判断当前最大数是否大于最大数，如果是则更新最大数

单调递减栈： 
1. 入栈时判断栈顶元素是否大于入栈元素
2. 若大于，则直接入栈
3. 若小于，则栈顶元素出栈，重复1

## 12.3 周四
### 204.计数质数
> BBTime：默默去查了查质数的定义：一个大于1，除了1和本身之外，不能被其他自然数整除的自然数，最小的质数是2

#### 按照定义写isPrime函数
```
private boolean isPrime(int n) {
        if (n <= 3) {
            return n > 1;
        }
        for (int i = 2; i < n; i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }
```
#### 优化1
对正整数 n ，如果用 2 到 √n 之间(包含边界)的所有整数去除，均无法整除，则 n 为质数。（由于因子的对称性）
```
 private boolean isPrime(int n) {
        if (n <= 3) {
            return n > 1;
        }
        int sqrt = (int) Math.sqrt(n);
        for (int i = 2; i <= sqrt; i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }
```
#### 厄拉多塞算法
思路：用空间换时间，每次判断一个数是质数后，将其倍数标记为合数。避免重复计算，有种备忘录的感觉。

### c5.替换空格
> BBTime：直接默写了答案。

如果正序替换，会造成大量元素重复移动。故选择逆向替换
![c5通过截图](../imgs/c5.jpg)

## 12.4 周五
### 659.分割数组为连续子序列
> BBTime：答案根本想不到，是对数据结构不熟悉吗，哈希表+最小堆，下次写题时先考虑适合哪种数据结构！

#### 1.哈希表+最小堆
1. 用最小堆维护子序列的长度
2. 哈希表`key`值存放以`key`为最后一个元素的子序列，`value`表示由以`key`为最后元素的子序列长度构成的最小堆

遍历数组，当遍历到元素x时，可以得到一个以x为结尾的子序列
1. 如果哈希表中存在x-1的key值，则取出x-1的最小堆的最小元素，使其+1，并存入以x为key的最小堆中
2. 如果哈希表中不存在~，则新建一个长度为1的以x结尾的子序列

#### 2.贪心算法
维护两个哈希表，思路感觉跟1差不多。

### c6.倒序打印链表
1. 常规思路就能想到用栈来存储链表元素
2. 先遍历一遍链表求长度，然后建立新数组，再遍历一遍链表，从后往前填充数组

### c7.重建二叉树
> BBTime：虽然做过，但还是做了挺长时间，主要是递归的时候指针没搞清楚，最开始只用两个指针，拿例子验证后发现要用四个指针

![第七题通过截图](../imgs/c7.jpg)
```
TreeNode build(int[] preorder, int prelo, int prehi, int[] inorder, int inlo, int inhi);
// 每次递归的时候，把退出条件和指针搞清楚就可以
```

## 12.5 周六
### 621.任务调度器
#### 模拟
> BBTime：我吐了，做了俩小时，最后参考了答案通过了。没参考答案之前，有个问题想不出来，就是如果有多个可以插入的字符，该选哪一个字符？
> 答案说该选重复次数多的那一个字符，证明还TM巨长无比，谁做个题还去写证明啊草。

![621通过截图](../imgs/621.jpg)
#### 构造/贪心/桶
> BBTime：主要是能把图画出来吧？数形结合？

![621图像](../imgs/621(2).png)

1. 出现最多的字符数量记为`N`，最后一行的数量记为`x`，则`NUMS1 = (N - 1) * (n + 1) + x` 
2. `NUMS2 = task.length`

`ret = Math.max(NUSM1, NUMS2)`

### 青蛙跳台阶
> BBTime：感觉是斐波那契数列，但是不知道怎么推导的

求**多少种可能性**的题目一般都有递推性质，即`f(n)`和`f(n-1)...f(1)`之间存在某种关系

设跳上`n`阶台阶有`f(n)`种跳法。在所有跳法中，青蛙的最后一步只有两种情况
1. 当为1级台阶时：剩`n-1`个台阶，此种情况共有`f(n-1)`种跳法
2. 当为2级台阶时：剩`n-2`个台阶，此种情况共有`f(n-2)`种跳法

所有`f(n) = f(n-1) + f(n-1)`


## 12.6 周日
### 118.杨辉三角
> BBTime：啊这，`O(n^2)`的代码都能超100%？代码还是写的不好，nums=0/1的时候都可以适配的。

### c11.旋转数组的最小数字
1. 年轻人不讲武德方法，直接`O(n)`遍历一遍找最小元素
2. 倒着找，如果`n[i] < n[i-1]`即`n[i]`为最小的元素
3. 可以用二分查找。。懒得看书了

### c12.矩阵数组中的路径
> BBTime：感天动地，小垃圾会写回溯了555 

![c12通过截图](../imgs/c12.jpg)

二维矩阵上找路径的问题都可以应用回溯法。

### c13.机器人的运动范围
直接遍历找为什么不对？？

我自己的回溯怎么直接爆栈了。。

判断条件可以统一写到`check`函数中

### c14. 割绳子
> 如果面试题是求一个问题的最优解，而且该问题能够分解成若干子问题，并且子问题之间还有重叠的更小子问题，就可以考虑用动态规划了。

## 12.7 周一
### 861.翻转矩阵后的得分
> BBTime：读完题后觉得是贪心，但是该怎么贪，思考了一下，感觉，没错，感觉是先把行排好，再排列

参考了别人的答案有两个哇塞的地方
1. 将0/1翻转，利用异或操作，`i ^= 1`
2. 计算列中的1时，可以不需要真正的翻转，只需要统计1的最大值就可以`Math.max(cnt, n-cnt)`

### 15.二进制中1的个数
最开始的版本没有考虑`n`是负数的情况，考虑负数后
1. 可以左移`1`
2. 可以左移`n`

NB的做法
`n-1`再和`n`相与会消掉`n`中最右边的`1`，消多少次就有多少个`1`

## 12.8 周二
### 842.将数组拆分成斐波那契序列（回溯）
> BBTime：只能想到穷举法，或者叫回溯？从头第一个字符开始确定是不是序列，但是卡在不知道怎么判断一个序列是不是斐波那契数列。
> 得，知道用回溯但是不知道怎么写代码~学习！
> 服了。。题都没看懂，人家要求的是拆分后的几个数是符合斐波那契序列，不是判断它是不是斐波那契数！

是一道要掌握的回溯题。

```
// 回溯算法经典模板
public void backtrack(args) {
    if(condition) //退出条件
        return;
    for(...) { 
        // 逻辑操作
        // 剪枝
        // 递归
        backtrack(xxx);
        // 是否回滚
        if...
    }
}
```
### 16.快速幂
做法类似二分法
1. `a^n = a^(n/2)*a^(n/2)`, `n`是否偶数时
2. `a^n = a^(n/2)*a^(n/2)*a`，`n`是奇数时

## 12.9 周三
### 62.不同路径
> BBTime：难得，还好以前做过类似的题目，知道思路

![62提交记录](../imgs/62.jpg)

方法
1. 回溯（超时）
2. 填表（看答案才知道这叫动态规划。。）
    
答案的动态规划方程，从头开始

`f(i,j) = f(i-1,j)+f(i,j-1)`

我写的动态规划方程，从尾开始

`f(i,j) = f(i+1，j) + f(i,j+1)`
    
### 17.打印从1到最大的n位数
> 主要考察大数问题

1. 最常用的是用字符串/数组表示大数。
2. 用字符串模拟加法（进位的问题）
3. 打印字符串表示的数字
4. 全排列的思路（递归） 

## 12.10 周四
### 860.柠檬水找零
> BBTime：今天又是底层人的一天                                                                                           

### 19.正则表达式匹配

## 12.11 周五
### 649.Dota2参议院
> BBTime：今天又是底层人的一天。我好烦啊，每次想到的都是最笨的办法，用最笨的数据结构，那咋整啊，总共那么些数据结构，一个个试呗，一个不行就组合用，草

![通过截图](../imgs/649.jpg)

用栈模拟，估计时间复杂度消耗在找当前节点后面的最近异节点上了。

用两个队列进行模拟（这谁能想的到），因为需要循环，所以进行一次后，索引+n

### 20.表示数值的字符串
> BBTime：爷累了，写个正则表达式都要写1个多小时，依旧是底层人

![通过截图](../imgs/c20.jpg)

表示数值的字符串模式
1. A[.[B]][e|EC]
2. .B[e|EC]

A表示整数部分，B表示小数部分，C表示整数部分

### 21.调整数组的顺序
可以利用快速排序的思想解决同一类问题：将数组分为两部分，前部分满足`fun()`，后部分满足`!fun()`，甚至可以写出一个模板来。

## 12.15 周二
> BBTime：周末躺了两天，周一干了一天活，真没意思啊
### 738.单调递增的数字
开始没思路，但是根据几个例子推一推，发现是回溯，但是递归的回溯又写不出来，就直接写迭代的了。

### 25.合并两个有序链表
注意是否可以修改原链表

## 12.16 周三
### 290.单词规律
用的哈希表来解决这道问题。方法还是从测试用例入手。

### 26.树的子结构
1. 找到和B相同的节点
2. 比较它们是否相等

一开始用列表存，发现不需要用列表存，找到节点时，直接比较即可，不需要多此一举

### 27. 二叉树的镜像
用前序遍历即可

## 12.22 周二
### 30.包含min函数的栈
最开始想用一个变量维护最小值，但是最小值出栈后，就要再找一遍次小值。

答案中直接用一个辅助栈维护最小值，入栈时进行判断
1. 如果比栈顶小，则直接入栈
2. 如果比栈顶大，则把栈顶再入一遍栈

### 31.栈的压入、弹出序列
根据测试用例来找到一个抽象的算法。直接用辅助栈进行模拟。

但是还是和答案的思路不一样。答案直接在每次入栈后，判断栈顶元素是否是出栈元素，若是，则弹出，直到不是。最后看栈是否为空即可。

我自己的思路时间浪费在查找出栈元素在入栈数组中的位置上了。

### 32.二叉树层序遍历
使用队列存储节点

### 32.II 层序遍历分层
记录每层节点个数和下层节点个数

## 12.23 周三
### 387.字符串中第一个唯一字符
用了两个哈希表
1. 存放字符出现的个数
2. 存放字符所在字符串中的索引

结果看了答案后，才知道第二个哈希表多此一举。。完全可以再把字符串遍历一遍，从头开始找个数为1的索引

### 35.复杂链表的复制
写出来之后有一个问题，如何定位到随机节点呢？val值有重复的情况下

## 12.25 周五
### 分发糖果
先排序，不排序直接找逻辑会有错误。

### 36.二叉搜索树与双向链表
一开始想着递归操作。但是写不出来，换了个思路，用列表把中序遍历的结点顺序存起来，然后按照列表顺序改变指针方向。

但是看了答案之后，发现也不是很难，主要是还是利用了中序遍历的递归框架。因为二叉搜索树的中序遍历就是有序的，每次遍历的节点是下一次遍历的前序节点，可以利用这个性质进行操作。
```
// pre 维护了当前链表的最大值（尾结点）
Node pre, head; 
void inorder(Node t) {
    if(t == null) return;
    inorder(t.left);
    // 具体操作逻辑
    if (pre == null) {
        head = t; // 设置链表的头结点
    } else {
        pre.right = t;
    }
    t.left = pre; 
    pre = t;
    inorder(t.right);
}
```

## 12.26 周六
### 37.序列化二叉树
> BBTime：对二叉树的操作优先考虑递归的方法

序列化用前序遍历，反序列化也要用前序遍历重新构建二叉树