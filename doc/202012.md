# 12月刷题记录

## 12.1 周二
### 34.在排序数组中查找元素的第一个和最后一个位置
> BBTime：12月份了！冲！今天开始打算除了leecode每日一题外，再加上一道剑指offer的题

这道题没什么好说的，可能只是单纯的考察二分查找吧

### c3.数组中的重复数字
常规思路：用哈希表记录出现的数量，再找哈希表中`value`大于1的`key`。
![c3通过截图](../imgs/c3.jpg)

优化1，在构建哈希表的时候就可以找到重复的数了。
![优化1通过截图](../imgs/c3(2).jpg)

优化2，因为题目中说到长度为`n`的`nums`数组范围`在0~n-1`内，所以直接用长度为`n`的数组替代`hashmap`。

![优化2通过截图](../imgs/c3(3).jpg)

使用空间复杂度为`O(1)`的算法，重排数组。

## 12.2 周三
### 321.拼接最大数
> BBTime：尝试了一下，只是单纯地找两个数组的最大值，比较一下，然后放到新数组中，但这也不一定是最大数啊。感觉不是我能做出来的git题，故放弃。

思路
1. 遍历`[k1, k2]`为` [0, k],[1,k-1],...[i, k-i],...[k, 0]`种组合时的最大数，且满足`k1 <= m, k2 <=n`
2. 找出两个数组中最大子序列（单调栈）
3. 将其合并
4. 判断当前最大数是否大于最大数，如果是则更新最大数

单调递减栈： 
1. 入栈时判断栈顶元素是否大于入栈元素
2. 若大于，则直接入栈
3. 若小于，则栈顶元素出栈，重复1

## 12.3 周四
### 204.计数质数
> BBTime：默默去查了查质数的定义：一个大于1，除了1和本身之外，不能被其他自然数整除的自然数，最小的质数是2

#### 按照定义写isPrime函数
```
private boolean isPrime(int n) {
        if (n <= 3) {
            return n > 1;
        }
        for (int i = 2; i < n; i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }
```
#### 优化1
对正整数 n ，如果用 2 到 √n 之间(包含边界)的所有整数去除，均无法整除，则 n 为质数。（由于因子的对称性）
```
 private boolean isPrime(int n) {
        if (n <= 3) {
            return n > 1;
        }
        int sqrt = (int) Math.sqrt(n);
        for (int i = 2; i <= sqrt; i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }
```
#### 厄拉多塞算法
思路：用空间换时间，每次判断一个数是质数后，将其倍数标记为合数。避免重复计算，有种备忘录的感觉。

### c5.替换空格
> BBTime：直接默写了答案。

如果正序替换，会造成大量元素重复移动。故选择逆向替换
![c5通过截图](../imgs/c5.jpg)

## 12.4 周五
### 659.分割数组为连续子序列
> BBTime：答案根本想不到，是对数据结构不熟悉吗，哈希表+最小堆，下次写题时先考虑适合哪种数据结构！

#### 1.哈希表+最小堆
1. 用最小堆维护子序列的长度
2. 哈希表`key`值存放以`key`为最后一个元素的子序列，`value`表示由以`key`为最后元素的子序列长度构成的最小堆

遍历数组，当遍历到元素x时，可以得到一个以x为结尾的子序列
1. 如果哈希表中存在x-1的key值，则取出x-1的最小堆的最小元素，使其+1，并存入以x为key的最小堆中
2. 如果哈希表中不存在~，则新建一个长度为1的以x结尾的子序列

#### 2.贪心算法
维护两个哈希表，思路感觉跟1差不多。

### c6.倒序打印链表
1. 常规思路就能想到用栈来存储链表元素
2. 先遍历一遍链表求长度，然后建立新数组，再遍历一遍链表，从后往前填充数组

### c7.重建二叉树
> BBTime：虽然做过，但还是做了挺长时间，主要是递归的时候指针没搞清楚，最开始只用两个指针，拿例子验证后发现要用四个指针
![第七题通过截图](../imgs/c7.jpg)
```
TreeNode build(int[] preorder, int prelo, int prehi, int[] inorder, int inlo, int inhi);
// 每次递归的时候，把退出条件和指针搞清楚就可以
```

## 12.5 周六
### 621.任务调度器
> BBTime：我吐了，做了俩小时，最后参考了答案通过了

![621通过截图](../imgs/621jpg)

没参考答案之前，有个问题想不出来，就是如果有多个可以插入的字符，该选哪一个字符？

答案说该选重复次数多的那一个字符。




