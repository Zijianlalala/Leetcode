# 11月刷题记录

## 11.18 周三 
### 加油站
暴力法
## 11.19 周四 
### 移动零
因为要求是原地操作，所以不能创建辅助数组。
但是可以利用两个指针来模拟新数组的建立。
第二个指针`j`表示新数组的索引。`O(n)`下就可以完成新数组的建立。最后再在数组后面补零即可。
## 11.20 周五 
### 147.对链表进行插入排序
思路就是常规思路，对单链表进行插入排序。主要优化了一个点：当前节点的值大于前序节点的值时，直接跳过此次排序。运行时间提高了`20ms`
## 11.21 周六  
### 148.排序链表 
今天效率低的要命，昨天做了用插入排序排序链表，今天换了个选择排序，结果超时了。。而且`O(nlogn)`的排序算法只想到快速排序，把归并给忘了，草。
## 11.22 周日  
### 242.有效的字母异位词 
永远是力扣底层人。。

![242通过截图](../imgs/242.jpg)

思路有两种
1. 排序
2. 哈希表

我是用的哈希表做的，排序没有想到，就是把两个字符串排序看它们是否相等即可。另外用的哈希表还真实诚地用了`Hashmap`，题目已知26个字母了，所以长度是26，可以用数组来构建哈希表，进行进一步优化。
1. `Hashmap`中有`getOrDefault(key, defaultValue)`，可以省掉自己的`if`判断的操作。
2. 数组初始化时，默认值是0

### 3.无重复字符的最长子串
`debug`了三次，推到了第一次的想法重来的，又一次`leetcode`人下人

![3通过截图](../imgs/3.jpg)

一开始是想用哈希表来判断字符有没有重复，但是有个问题，哈希表没法判断已存的子串的顺序，所以也没办法记忆重复字符后面的字符，只能全部消除。

后来又想可不可以用一个变量维护一个最长子串，所有操作对这个变量进行，长度也好维护。

我发现目前我总是习惯用代码去描述/表达算法的过程，虽然通常可以实现，但是却不是最优解。

比如此题，我想去维护一个最长子串，就真的用`StringBuilder`去维护整个子串了，而答案中仅用左右两个指针就表示了。

## 11.24 周二
### 222.完全二叉树的结点数
> 周一下午到晚上都在外面干活。。回来就懒得打卡了

![222通过截图](../imgs/222.jpg)

今天的题蛮常规的，遍历就可以了。

## 11.24 周三

### 1370.上升下降字符串
每次这种题都会想办法用代码去模拟算法，尽可能具体的把每一步写出来，但是要不写不出来，要不写出的代码鲁棒性很差。

比如今天这道题，想办法模拟，但是又囿于各种条件牵扯。

然而一般答案都不会直接去模拟算法，都是用巧劲，尽可能得抽象，而不是具体。

**桶计数**
1. 字符只有26个小写字母 
2. 数组当做哈希表，`key`值是`ch-'a'`，这样就可以把26个字母和数组的26个索引一一对应

 感觉这题就是为了这种思路而出的，不是说这个思路解决了这个问题。正向遍历一遍数组，在逆向遍历一遍数组。
 
 
