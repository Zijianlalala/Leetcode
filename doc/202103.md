# 3月份刷题记录

## 3.7 周日
### 5.最长回文子串
#### 暴力算法
自己写的暴力超时，答案的暴力却能击败`50%`。与答案不同的几个点
1. 只遍历超过当前最长回文长度的子串。
2. 将字符串转化为数组，判断是否是回文时，传递指针，而非整个子串。
3. 长度为1的子串不进行判断。
#### 动态规划
原理：回文子串左右两边加上同样的字符还能构成回文串

动态规划转移方程
```
P(i,j) = P(i+1, j-1) ^ (Si == Sj)
```

边界条件
1. 长度==1时，`dp[i][j]=true`
2. 长度==2时，`dp[i][j] = s[i]==s[j]`
3. 长度>2时，`dp[i][j] = dp[i+1][j-1] && (s[i]==s[j])`

### 6.Z字形变换
#### 模拟
常规思路，模拟填充过程。答案用以下语句实现了Z字走动。
```
if (i == 0 || i == rows-1) 
    flag = -flag;
i += flag;
```

### 7.整数反转
一个简单题，还只能击败`5%`的人。ORZ。不好意思，原来是打印语句没有注释掉。打扰了。立即`100%`

### 9.回文数
判断整型数是不是回文数
1. 转换为字符串进行判断
2. 将数字的每一位装进双向队列中，若收尾相等则同时出列。
3. 翻转数字的一半来与操作后的源数字进行判断是否相等

## 3.8 周一
### 11. 盛最多水的容器
1. 暴力超时
2. **双指针法**，从最外围的两个壁向内部移动
    1. 向内移动短板，则新板可能会变大
    2. 向内移动长板，则短板不变，面积不变或减少
   
### 12.整数转罗马数字

### 14.最长公共前缀
1. 暴力

### 15. 三数之和
答案：排序+双指针

双指针法特点：两个指针在边界，根据条件相向移动指针。

思路：
1. 固定k指针，使它指向最左边的值
2. i和j指向(k, len(nums))
3. i,j想内夹逼，找到目标值

**两数之和**

### 19. 删除链表的倒数第K个结点
这个题做了N遍了。
1. 双指针
2. 设置一个空节点作为头结点，方便统一操作节点

### 22.括号生成
用回溯自己做出来啦！但是只击败了`30%`
 
### 31.下一个排列
没读懂题意，就是求比目前序列大的最小序列。从单个例子中推到思路。
放弃了。。

### 33.搜索旋转排序数组
旋转数组：局部有序，也可以用二分查找。

与普通二分查找的区别：
1. 变换上下限，先判断区间是否有序。
   * 若有序，则在目标值是否在区间内部
      1. 若在，则将上下限改为此区间
      2. 若不在，则将上下线改为另一半的区间
   * 若此区间无序，则另一半区间一定有序
   
### 46.全排列
回溯

注意回溯函数里面中的`for`循环
```
for(int i = first; i < n; i++) {
   swap(nums, i, first);
   backtrack(nums, first + 1);
   swap(nums, i, first);
}
```

## 3.9 周二
### 48.旋转图像
顺时针90度旋转2维矩阵。没思路
1. 可以使用辅助数组吗？可以->将第N行放到新数组的倒数第N列上
2. 原地旋转
    1. 先上下翻转，再主对角线翻转得到旋转矩阵。
    
放弃了
### 49.字母异位词分组
1. 将词按照字典序排序，并将其作为key值
2. value值存放key值相同的单词列表

### 50.最大连续子序列和
妈的，看到连续以为是双指针题。然后没做出来，看答案是**动态规划**。。

思路
1. 设`f(i)`为以第`i`个数结尾的连续子数组最大和
2. 动态规划方程为`f(i)= max{f(i-1) + nums[i], nums[i]}`

### 55.跳跃游戏
这算啥题，分析一下题干，提取出条件编码即可。

思路：碰到元素0时，判断0之前的位置是否能跳过0元素。

看答案后：原来还能这么做。贪心算法

思路：维护一个能最远到达的位置，当该位置超过或等于数组长度-1时，就可以到达最后一个位置。

### 64.最小路径和
熟悉的题。我记得回溯会超时。经验证是会超时的。
1. 回溯超时
2. 填表（动态规划）无需新建表格，直接使用原表格即可。


    

