# 3月份刷题记录

# 第2周
## 3.7 周日
### 5.最长回文子串
#### 暴力算法
自己写的暴力超时，答案的暴力却能击败`50%`。与答案不同的几个点
1. 只遍历超过当前最长回文长度的子串。
2. 将字符串转化为数组，判断是否是回文时，传递指针，而非整个子串。
3. 长度为1的子串不进行判断。
#### 动态规划
原理：回文子串左右两边加上同样的字符还能构成回文串

动态规划转移方程
```
P(i,j) = P(i+1, j-1) ^ (Si == Sj)
```

边界条件
1. 长度==1时，`dp[i][j]=true`
2. 长度==2时，`dp[i][j] = s[i]==s[j]`
3. 长度>2时，`dp[i][j] = dp[i+1][j-1] && (s[i]==s[j])`

### 6.Z字形变换
#### 模拟
常规思路，模拟填充过程。答案用以下语句实现了Z字走动。
```
if (i == 0 || i == rows-1) 
    flag = -flag;
i += flag;
```

### 7.整数反转
一个简单题，还只能击败`5%`的人。ORZ。不好意思，原来是打印语句没有注释掉。打扰了。立即`100%`

### 9.回文数
判断整型数是不是回文数
1. 转换为字符串进行判断
2. 将数字的每一位装进双向队列中，若收尾相等则同时出列。
3. 翻转数字的一半来与操作后的源数字进行判断是否相等

## 3.8 周一
### 11. 盛最多水的容器
1. 暴力超时
2. **双指针法**，从最外围的两个壁向内部移动
    1. 向内移动短板，则新板可能会变大
    2. 向内移动长板，则短板不变，面积不变或减少
   
### 12.整数转罗马数字

### 14.最长公共前缀
1. 暴力

### 15. 三数之和
答案：排序+双指针

双指针法特点：两个指针在边界，根据条件相向移动指针。

思路：
1. 固定k指针，使它指向最左边的值
2. i和j指向(k, len(nums))
3. i,j想内夹逼，找到目标值

**两数之和**

### 19. 删除链表的倒数第K个结点
这个题做了N遍了。
1. 双指针
2. 设置一个空节点作为头结点，方便统一操作节点

### 22.括号生成
用回溯自己做出来啦！但是只击败了`30%`
 
### 31.下一个排列
没读懂题意，就是求比目前序列大的最小序列。从单个例子中推到思路。
放弃了。。

### 33.搜索旋转排序数组
旋转数组：局部有序，也可以用二分查找。

与普通二分查找的区别：
1. 变换上下限，先判断区间是否有序。
   * 若有序，则在目标值是否在区间内部
      1. 若在，则将上下限改为此区间
      2. 若不在，则将上下线改为另一半的区间
   * 若此区间无序，则另一半区间一定有序
   
### 46.全排列
回溯

注意回溯函数里面中的`for`循环
```
for(int i = first; i < n; i++) {
   swap(nums, i, first);
   backtrack(nums, first + 1);
   swap(nums, i, first);
}
```

## 3.9 周二
### 48.旋转图像
顺时针90度旋转2维矩阵。没思路
1. 可以使用辅助数组吗？可以->将第N行放到新数组的倒数第N列上
2. 原地旋转
    1. 先上下翻转，再主对角线翻转得到旋转矩阵。
    
放弃了
### 49.字母异位词分组
1. 将词按照字典序排序，并将其作为key值
2. value值存放key值相同的单词列表

### 50.最大连续子序列和
妈的，看到连续以为是双指针题。然后没做出来，看答案是**动态规划**。。

思路
1. 设`f(i)`为以第`i`个数结尾的连续子数组最大和
2. 动态规划方程为`f(i)= max{f(i-1) + nums[i], nums[i]}`

### 55.跳跃游戏
这算啥题，分析一下题干，提取出条件编码即可。

思路：碰到元素0时，判断0之前的位置是否能跳过0元素。

看答案后：原来还能这么做。贪心算法

思路：维护一个能最远到达的位置，当该位置超过或等于数组长度-1时，就可以到达最后一个位置。

### 64.最小路径和
熟悉的题。我记得回溯会超时。经验证是会超时的。
1. 回溯超时
2. 填表（动态规划）无需新建表格，直接使用原表格即可。

### 70. 爬楼梯
动态规划（类似斐波那契数列）
`f(n) = f(n-1)+ f(n-2)` 

### 75.颜色分类
1. 快速排序。
2. 两次遍历分别移动0和1

### 78.子集
> 凡是题干简单但是做不出来的题都是好题 ——wzj

看了答案发现竟然和全排列一样，都是用回溯。

```
backtrack(int[] nums, int idx) {
    if (idx <= nums.length) 
        ans.add(temp);
    for(int i = idx; i < nums.length; i++) {
        temp.add(nums[i]);
        backtrack(nums, i+1);
        temp.remove(temp.size()-1);
    }
}

```

### 79. 单词搜索
又是回溯。。一开始做不下去的原因是在如何定位第一个元素上，直接使用双层循环挨个遍历元素。

### 102. 二叉树层序遍历
要点
1. 利用队列存储节点
2. 计算每层的节点个数

### 101.对称二叉树
首先分析特点，根据特点进行递归
1. 左右子树的根节点相同
2. 左子树的左子树与右子树的右子树镜像/左子树的右子树与右子树的左子树镜像

### 1047. 删除字符串中的所有相邻重复项
1. 对字符数组进行操作，不断删除重复项（打败`50%`)
2. 用栈！！！竟然没看出来。。简直就是为栈设计的。

## 3.10 周三
### 224.基本计算器
思路：借助两个栈实现运算。注意有负数的存在。

### 96.不同的二叉搜索树
没有思路。。总感觉是数学题。不会又是回溯吧。好吧，有数学解法
1. 动态规划
2. 卡塔兰数

动态规划的思路
1. 整数`1,2,...,k,...n`中，若以`k`为根，则`1..k-1`构建左子树，`k+1...n`构建右子树
2. 以k根结点的BST种类=左子树种类 * 右子树种类

特点：个数相同的连续n个数，构建出的BST种类数相同。

假设n个结点存在的BST数是`G(n)`，令`f(i)`为以i为根的二叉搜索树的个数，则
```
G(n) = f(1) + f(2) + ... + f(n) 
```
当`i`为根结点时，其左子树节点个数为`i-1`，右子树节点个数为`n-i`，则
```
f(i) = G(i-1) * G(n-i)
```
综合两个公式得
```
G(n) = G(0)*G(n-1) + G(1)*G(n-2) + ... + G(n-1)*G(0)
```

### 98.验证二叉搜索树
自己写的递归函数有个问题：不能判断子树中的最小值与比根的关系，因为只判断当前结点和其左右孩子结点的关系，没有全局来看大小关系。

看答案是
1. 中序遍历的结果是有序序列，判断前一个结点是比当前结点小。
2. 递归。将大小范围不断缩小。

### 114.二叉树展开为链表
1. 用队列存储二叉树前序序列，然后重新构建链表
2. 将右子树连到左子树最右边节点，再讲左子树接到原来右子树的位置上。

### 121.买卖股票的最佳时机
一次遍历即可，假设当日卖出，如果卖出的钱大于最大利益就更新最大利益，同时维护一个当前最小买入金额。

### 136.只出现一次的数字
1. 利用哈希表统计每个数字出现的次数
2. **异或运算**

### 139.单词拆分
烦死了，做了40分钟的暴力还超时了。。

看答案，服了，怎么又是动态规划。

定义`dp[i]`表示字符串`s`的前`i`个字符`(0,1,...,i-1)`能否被列表项拆分，所以转移方程如下
```
dp[0]=true;
dp[i] = dp[j] && check(j, i-1)
```

### 141.判断是否是环形链表
1. 用set存储节点，遍历节点的时候判断是否有重复节点
2. 快慢指针（空间复杂度`O(1)`)

如果要返回环形链表的入口，快慢指针需要同时从根节点出发。

## 3.11 周四
### 152.乘积最大的数组
开心的以为自己会用动态规划了，但是做了之后发现不对。。以为涉及到负数的情况，有时候最小值×当前值会变成最大值，所以新的dp方程是
```
maxF[i] = max{max[i-1] * nums[i], nums[i], minF[i-1] * nums[i]} 维护最大值
minF[i] = min{min[i-1] * nums[i], nums[i], maxF[i-1] * nums[i]} 维护最小值
```

### 155.最小栈

### 160.相交链表

### 169.多数元素
1. 排序+中间元素
2. 哈希表存数组出现频率

### 198. 打家劫舍
5555终于自己做出来一道dp题了。。

动态规划方程
```
dp[i] = max{dp[0]+nums[i], dp[1]+nums[i], ... , dp[i-2]+nums[1]}
```
### 206.翻转链表
1. 迭代
2. 递归（head.next.next = head)

### 207.课程表
不会做。
思路：题干是判断是否是有向无环图（DAG）。使用拓扑排序判断。

深度优先找环：
将每个节点分为三种状态
1. flag[i] == 0 //未访问
2. flag[i] == 1 //本轮已访问 
3. flag[i] == -1 //被其他轮次访问过


## 3.12 周五
### 331.验证二叉树的前序序列化
做了50分钟。。不过能做来还是挺开心的了。

思路：递归判断子树是不是满足二叉树。分治法。
### 146.缓存机制
被提示是hashmap+链表，结果做出来看答案跟答案的思路不一样，人家的map是存放链表的位置，我的map存放的是链表的value值。

为什么使用双向链表？因为双向链表删除一个节点的（已知他的位置）的时间复杂度是`O(1)`，因为直接通过`pre`指针就可以获得到他的前序节点。

删除尾结点也是`O(1)`是因为维护了尾结点的引用。

## 3.13 周六
### 705.设计哈希集合
思路：数组+链表+哈希算法。将哈希函数中的取余运算的值设置为质数会提升效率。（避免冲突）

答案链表用的`LinkedList`

### 208.实现前缀树Trie
前缀树/字典树/单词查找数——非典型的多叉树模型。

```
class TrieNode {
    boolean isEnd;
    TrieNode[] links;
    public TrieNode(){links = new TrieNode[26];}
    
    boolean contains(char c) {return links[c-'a'] != null;}
    
    void put(char c, TrieNode node){
        links[c-'a'] = node;
    }
    
    TrieNode get(char c) {
        return links[c-'a'];
    }
}

```

###  209.长度最小的子数组
思路：双指针（滑动窗口）

### 215.数组中的第K个最大元素
思路：快速排序

备注：快排选择pivot时，随记选择会提供效率
```
int  r =  new Random().nextInt(hi - lo + 1) + lo;
swap(nums, lo, r);
int pivot = nums[lo];
```
### 226.翻转二叉树
递归翻转

### 234.回文链表
思路
1. 将链表复制到数组中，判断数组是否是回文（双指针法）
2. 递归

### 236.二叉树的最近公共祖先
记得做过，思路是打印两条路径，然后从头进行对比。但是打印路径又忘记怎么做了

看答案说是用后序遍历。

定义：设节点root是节点p、q的公共祖先，若其左子节点root.left和其右子节点root.right都不是p、q的公共祖先，则root是p、q的最近公共祖先。

若root是p、q的最近公共祖先，有以三种情况
1. p、q在root的子树中，且分别异侧（分处左、右子树）。
2. p == root，则q在root的子树中。
3. q == root，则p在root的子树中。

### 238.除自身以外数组的乘积
以前做过，用两个辅助数组存放累乘的值，然后相乘得出结果。

### 279.完全平方数
不会哦。看答案竟然可以用动态规划做。

```
dp[i] = min{dp[i-1*1]+1, dp[i-2*2]+1, dp[dp-3*3]+1, ..., dp[dp-k*k]+1} k*k <= i
```
### 287.寻找重复数
剑指offer03

### 300.最长递增子序列
动态规划

## 3.14 周日
### 337.打劫家舍III
动态规划、后序遍历

当dp问题出现在**树**结构上，通常采用后续遍历，逻辑是通过子节点陆续汇报信息给父节点，层层向上汇报，最后在根结点汇总。

# 第3周
## 3.15 周一
### 54.螺旋矩阵
剑指offer原题，但是还是忘记思路是什么了。

思路：维护四个变量，`（top,left)`和`(bottom,right)`表示左上节点和右下节点。每次遍历都是输出外围节点，遍历一次后更新顶点的值。

### 347.前K个高频元素
自己的思路也是hashmap+快速排序。注意快速排序的元素应该是一个数组（且有两个值），或者实体类存放两个值(key, times)，然后根据times进行排序

答案：hashmap+堆

### 394.字符串解码
模拟，用递归代替栈

### 406.根据身高重建列表
算法课的作业题。现根据身高排序，如果身高相同，再根据排序。

生成二维数组的方法：
```
List<int[]> ans;
return ans.toArray(new int[ans.size()][]);
```

## 3.16 周二
### 59. 螺旋矩阵 II
注意边界条件，维护左上顶点(top, left)和右下顶点(bottom, right)

### 437.路径总和 III
1. 树的后续遍历
2. Hash表key值存放一个节点，value值存放链表，链表中存放以该节点为起点的所有路径和

### 438.找到字符串中所有字母异位词
1. 暴力超时
2. 又花了一个小时，用滑动窗口做。

### 448.找到所有数组中消失的数字
用原数组作为哈希表，将出现的数字所在的索引上的值+n，判断数组小于n的索引即可
### 461.汉明距离
1. 异或
2. 统计二进制数中1的个数

## 3.17 周三
### 115.不同的子序列
回溯到54/62时超时。

看答案是用动态规划
```
dp[i][j]表示的是从i开始的s子串中含有从j开始的t子串的数量
边界条件：dp[i][n]=1
if(s[i] == t[j])
    dp[i][j] = dp[i+1][j-1] + dp[i+1][j];
else
    dp[i][j] = dp[i+1][j];
```

### 543.二叉树的直径
后续遍历找每个结点左子树和右子树路径合的最大值
### 617.合并二叉树
递归前序遍历即可

## 3.18 周日
### 92.反转链表II

### 739.每日温度
暴力竟然没有超时。。还击败了5%的用户。

看答案是单调栈。好好学习一下。

### 647.回文子串
回溯？也算暴力吧。击败了9.8%。

### 560.和为K的数组
动态规划填二维表导致超过内存限制。

### 581.最短无序连续子数组
利用栈找到左边节点和右边节点，然后返回right-left+1

## 3.19 周五
### 538.把二叉搜索树转换为累加树
1. 中序遍历用栈保存节点列表，然后遍历栈，更新每个节点的值
2. 自定顺序遍历，一次遍历并维护节点值即可。（node.right,node,node,left）

## 3.20 周六
### 150.逆波兰表达式求值
用栈保存操作数


 


